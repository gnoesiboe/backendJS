/**
 * @param {Function} Inheritance
 * @param {Function} Logger
 * @param {Function} Callback
 *
 * @returns {Function}
 */
module.exports  = function(Inheritance, Logger, Callback) {

    /**
     * @type {Object}
     */
    var _ = require('underscore/underscore');

    /**
     * @constructor
     */
    var Observer = function() {

        /**
         * @type {Array}
         */
        this._callbacks = {};

        /**
         * @type {Object}
         */
        this._logger = null;

        Observer.prototype._init.apply(this, arguments);
    };

    _.extend(Observer.prototype, {

        /**
         * Initiates this object
         */
        _init: function() {
            this._logger = new Logger('[observer]');
        },

        /**
         * @param {Array|String} events
         */
        _addEvents: function(events) {
            if (_.isArray(events) === false) {
                events = [ events ];
            }

            for (var key in events) {
                this._addEvent(events[key]);
            }
        },

        /**
         * @param {String} event
         * @return {Object}
         */
        _addEvent: function(event) {
            if (this.hasEvent(event) === false) {
                this._callbacks[event] = [];
            }

            this._logger.logInfo('registered event: \'' + event + '\'');

            return this;
        },

        /**
         * @param {String} event
         * @returns {Boolean}
         */
        hasEvent: function(event) {
            return this._callbacks.hasOwnProperty(event);
        },

        /**
         * @param {string} event
         * @param {Object} params
         */
        _trigger: function(event, params) {
            this._validateEvent(event);
            this._validateHasEvent(event);

            var callbacks = this._callbacks[event];

            this._logger.logInfo('Triggered \'' + event + '\' event. Listener count: ' + callbacks.length);

            for (var key in callbacks) {
                if (callbacks.hasOwnProperty(key)) {
                    var callback = callbacks[key];

                    callback.getCallback().call(callback.getContext() || this, params || {});
                }
            }
        },

        /**
         * @param {String} event                Event identifier
         * @param {Function} callback           Function that is called when this event fires
         * @param {Object} callbackContext      (optional) Context that the callback is called in when the event fires
         *
         * @return {Object}
         */
        add: function(event, callback, callbackContext) {
            this._validateEvent(event);

            this._callbacks[event].push(new Callback(callback, callbackContext || this));

            return this;
        },

        /**
         * @param {String} event
         * @param {Function} callback
         * @param callbackContext
         * @returns {boolean}
         */
        remove: function(event, callback, callbackContext) {
            this._validateEvent(event);

            var eventCallbacks = this._callback[event],
                indexesToRemove = [];

            for (var i = 0, l = eventCallbacks.length; i < l; i++) {
                var supposedCallback = eventCallbacks[i];

                if (supposedCallback.hasCallback(callback) === true && supposedCallback.hasContext(callbackContext || this) === true) {
                    indexesToRemove.push(i);
                }
            }

            if (indexesToRemove.length > 0) {
                for (var index in indexesToRemove) {
                    this._callback[event].splice(index, 1);
                }

                return true;
            }
            else {
                return false;
            }
        },

        /**
         * @param {String} event
         * @throws {Error}
         */
        _validateHasEvent: function(event) {
            if (this.hasEvent(event) === false) {
                throw new Error('No event registered with identifier: ' + event);
            }
        },

        /**
         * @param {String} event
         * @throws {Error}
         */
        _validateEvent: function(event) {
            if (_.isString(event) === false) {
                throw new Error('Event identifier should be of type String');
            }

            this._validateHasEvent(event);
        }
    });

    Observer.extend = (new Inheritance).extend;

    return Observer;
};